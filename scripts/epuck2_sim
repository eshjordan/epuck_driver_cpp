#!/usr/bin/env python3

# Run a simple socket server to test the e-puck driver
# Usage: epuck_sim [-h] [--ip IP] [--port PORT]

import argparse
import signal
import socket
import struct
import time
from dataclasses import dataclass


ENDIAN_FMT = "<"


@dataclass
class EpuckSensorPacket:
    id: int = 0x2  # byte
    imu_acc_x: int = 0  # short
    imu_acc_y: int = 0  # short
    imu_acc_z: int = 0  # short
    imu_acceleration: float = 0
    imu_orientation: float = 0
    imu_inclination: float = 0
    imu_gyro_x: int = 0  # short
    imu_gyro_y: int = 0  # short
    imu_gyro_z: int = 0  # short
    imu_magnetometer_x: float = 0
    imu_magnetometer_y: float = 0
    imu_magnetometer_z: float = 0
    imu_temp: int = 0  # byte
    ir_proximity_0: int = 0  # unsigned short
    ir_proximity_1: int = 0  # unsigned short
    ir_proximity_2: int = 0  # unsigned short
    ir_proximity_3: int = 0  # unsigned short
    ir_proximity_4: int = 0  # unsigned short
    ir_proximity_5: int = 0  # unsigned short
    ir_proximity_6: int = 0  # unsigned short
    ir_proximity_7: int = 0  # unsigned short
    ir_ambient_0: int = 0  # unsigned short
    ir_ambient_1: int = 0  # unsigned short
    ir_ambient_2: int = 0  # unsigned short
    ir_ambient_3: int = 0  # unsigned short
    ir_ambient_4: int = 0  # unsigned short
    ir_ambient_5: int = 0  # unsigned short
    ir_ambient_6: int = 0  # unsigned short
    ir_ambient_7: int = 0  # unsigned short
    tof_distance: int = 0  # unsigned short
    mic_0: int = 0  # unsigned short
    mic_1: int = 0  # unsigned short
    mic_2: int = 0  # unsigned short
    mic_3: int = 0  # unsigned short
    motor_left_steps: int = 0  # short
    motor_right_steps: int = 0  # short
    bat_adc_value: int = 0  # unsigned short
    usd_state: int = 0  # byte
    tv_remote_toggle: int = 0  # byte
    tv_remote_addr: int = 0  # byte
    tv_remote_data: int = 0  # byte
    selector_position: int = 0  # byte
    ground_sensor_proximity_0: int = 0  # unsigned short
    ground_sensor_proximity_1: int = 0  # unsigned short
    ground_sensor_proximity_2: int = 0  # unsigned short
    ground_sensor_ambient_0: int = 0  # unsigned short
    ground_sensor_ambient_1: int = 0  # unsigned short
    ground_sensor_ambient_2: int = 0  # unsigned short
    button_state: int = 0  # byte
    reserved_empty: int = 0  # byte

    def pack(self):
        return struct.pack(
            ENDIAN_FMT + "BhhhfffhhhfffBHHHHHHHHHHHHHHHHHHHHHhhHBBBBBHHHHHHBB",
            self.id,
            self.imu_acc_x,
            self.imu_acc_y,
            self.imu_acc_z,
            self.imu_acceleration,
            self.imu_orientation,
            self.imu_inclination,
            self.imu_gyro_x,
            self.imu_gyro_y,
            self.imu_gyro_z,
            self.imu_magnetometer_x,
            self.imu_magnetometer_y,
            self.imu_magnetometer_z,
            self.imu_temp,
            self.ir_proximity_0,
            self.ir_proximity_1,
            self.ir_proximity_2,
            self.ir_proximity_3,
            self.ir_proximity_4,
            self.ir_proximity_5,
            self.ir_proximity_6,
            self.ir_proximity_7,
            self.ir_ambient_0,
            self.ir_ambient_1,
            self.ir_ambient_2,
            self.ir_ambient_3,
            self.ir_ambient_4,
            self.ir_ambient_5,
            self.ir_ambient_6,
            self.ir_ambient_7,
            self.tof_distance,
            self.mic_0,
            self.mic_1,
            self.mic_2,
            self.mic_3,
            self.motor_left_steps,
            self.motor_right_steps,
            self.bat_adc_value,
            self.usd_state,
            self.tv_remote_toggle,
            self.tv_remote_addr,
            self.tv_remote_data,
            self.selector_position,
            self.ground_sensor_proximity_0,
            self.ground_sensor_proximity_1,
            self.ground_sensor_proximity_2,
            self.ground_sensor_ambient_0,
            self.ground_sensor_ambient_1,
            self.ground_sensor_ambient_2,
            self.button_state,
            self.reserved_empty,
        )

    @classmethod
    def unpack(cls, buffer: bytes):
        args = struct.unpack(
            ENDIAN_FMT + "BhhhfffhhhfffBHHHHHHHHHHHHHHHHHHHHHhhHBBBBBHHHHHHBB",
            buffer,
        )
        return cls(*args)

    @classmethod
    def calcsize(cls):
        return struct.calcsize(
            ENDIAN_FMT + "BhhhfffhhhfffBHHHHHHHHHHHHHHHHHHHHHhhHBBBBBHHHHHHBB"
        )


@dataclass
class EpuckCommandPacket:
    command: int = 0x80  # byte
    request_flags: int = 0  # byte
    settings_flags: int = 0  # byte
    motors_left: int = 0  # short
    motors_right: int = 0  # short
    leds_state: int = 0  # byte
    rgb_leds_led2_r: int = 0  # byte
    rgb_leds_led2_g: int = 0  # byte
    rgb_leds_led2_b: int = 0  # byte
    rgb_leds_led4_r: int = 0  # byte
    rgb_leds_led4_g: int = 0  # byte
    rgb_leds_led4_b: int = 0  # byte
    rgb_leds_led6_r: int = 0  # byte
    rgb_leds_led6_g: int = 0  # byte
    rgb_leds_led6_b: int = 0  # byte
    rgb_leds_led8_r: int = 0  # byte
    rgb_leds_led8_g: int = 0  # byte
    rgb_leds_led8_b: int = 0  # byte
    speaker_sound_id: int = 0  # byte

    def pack(self):
        return struct.pack(
            ENDIAN_FMT + "BBBhhBBBBBBBBBBBBBB",
            self.command,
            self.request_flags,
            self.settings_flags,
            self.motors_left,
            self.motors_right,
            self.leds_state,
            self.rgb_leds_led2_r,
            self.rgb_leds_led2_g,
            self.rgb_leds_led2_b,
            self.rgb_leds_led4_r,
            self.rgb_leds_led4_g,
            self.rgb_leds_led4_b,
            self.rgb_leds_led6_r,
            self.rgb_leds_led6_g,
            self.rgb_leds_led6_b,
            self.rgb_leds_led8_r,
            self.rgb_leds_led8_g,
            self.rgb_leds_led8_b,
            self.speaker_sound_id,
        )

    @classmethod
    def unpack(cls, buffer: bytes):
        args = struct.unpack(ENDIAN_FMT + "BBBhhBBBBBBBBBBBBBB", buffer)
        # 0001 1001
        return cls(*args)

    @classmethod
    def calcsize(cls):
        return struct.calcsize(ENDIAN_FMT + "BBBhhBBBBBBBBBBBBBB")


class EpuckModel:
    wl_pos: int = 0
    wr_pos: int = 0
    wl_vel: float = 0
    wr_vel: float = 0

    def get_steps(self, dt):
        wl_steps = self.wl_pos + round(self.wl_vel * dt)
        wr_steps = self.wr_pos + round(self.wr_vel * dt)

        # Steps are between -32768-32767
        if wl_steps > 32767:
            wl_steps -= 65536
        elif wl_steps < -32768:
            wl_steps += 65536

        if wr_steps > 32767:
            wr_steps -= 65536
        elif wr_steps < -32768:
            wr_steps += 65536

        self.wl_pos = wl_steps
        self.wr_pos = wr_steps

        return self.wl_pos, self.wr_pos

    def update_speed(self, msg: EpuckCommandPacket):
        self.wl_vel = msg.motors_left  # steps / second
        self.wr_vel = msg.motors_right
        return


sock: socket.socket


def main(server_address):
    # Create a TCP/IP socket
    global sock
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

    # Bind the socket to the address and port
    print("Starting up on {} port {}".format(*server_address))
    sock.bind(server_address)

    # Listen for incoming connections
    sock.listen(1)

    model = EpuckModel()

    while True:
        # Wait for a connection
        print("Waiting for a connection")
        connection, client_address = sock.accept()
        try:
            print("Connection from", client_address)
            last_update_time = time.time()

            # Receive the command data and respond appropriately
            while True:
                data = connection.recv(EpuckCommandPacket.calcsize())
                if data:
                    # Unpack the data into a command message
                    msg = EpuckCommandPacket.unpack(data)
                    start_img_stream = (msg.request_flags & 0b01) > 0
                    start_sensors_stream = (msg.request_flags & 0b10) > 0

                    # Image stream request
                    if start_img_stream:
                        connection.send(bytes([3]))  # Not implemented, skip

                    # Sensor stream request
                    if start_sensors_stream:
                        # Calculate the time since the last data was received
                        current_time = time.time()
                        dt = current_time - last_update_time
                        last_update_time = current_time

                        # Determine the number of steps the motors have moved based on the previously set speed
                        left_steps, right_steps = model.get_steps(dt)

                        # Update the speed of the motors
                        model.update_speed(msg)

                        # Create a sensor message and send it back, only motor steps implemented so far
                        sensor_msg = EpuckSensorPacket()
                        sensor_msg.motor_left_steps = left_steps
                        sensor_msg.motor_right_steps = right_steps
                        packed = sensor_msg.pack()
                        connection.sendall(packed)

                else:
                    print("No data from", client_address)
                    break

        except Exception as e:
            print(f"Exception: {e}")

        finally:
            # Clean up the connection
            connection.close()
            time.sleep(1)
            print("Connection closed")
            break


if __name__ == "__main__":
    signal.signal(signal.SIGINT, lambda _: sock.close())
    arg_parser = argparse.ArgumentParser(description="Test server for e-puck driver")
    arg_parser.add_argument(
        "--ip", type=str, default="192.168.1.1", help="IP address of this server"
    )
    arg_parser.add_argument(
        "--port", type=int, default=10000, help="Port number of this server"
    )
    args = arg_parser.parse_args()
    main((args.ip, args.port))
